\documentclass{report}
\usepackage{graphicx}
\usepackage{xepersian}
\usepackage{geometry}
\settextfont[Scale=1.2]{XB Zar}

% section numbering
\setcounter{secnumdepth}{3}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesection.\arabic{subsection}.\arabic{subsubsection}}

\title{ 
\begin{normalsize} به نام خدا \end{normalsize}
\\[7cm]
طراحی نقشه ساختمان با استفاده از پردازش تکاملی
\\[3cm]
}
\author{علیرضا نوریان
\\
\\ \small دانشگاه علم و صنعت ایران
\\ \small noorian@comp.iust.ac.ir
}

\begin{document}
\maketitle

\tableofcontents

\begin{abstract}

\end{abstract}

\section{مقدمه}
زندگی مدرن برای بشر مزایا و البته معایب بسیار زیادی به همراه آورده است. بسیاری از مشکلات حاصل از زندگی نو ریشه‌های عمیق فرهنگی دارند و شاید پاسخهای متناسب با ارزشهای دنیای جدید، برای آنها مناسب نباشند ولی در همه موارد این حرف صحیح نیست. پروژه‌ی پیش‌رو نمونه‌ای از حل مشکلات دنیای نو با استفاده از راهکارهای آن است. به طور مختصر می‌توان گفت هدف این پروژه فراهم کردن خانه‌های عملکردگرا برای سازنده‌ی مقتصد است که البته خریدار محکوم به زندگی در دنیای جدید از آن نفع خواهد برد.

به وجود آمدن مفهوم «بازار مسکن» را می‌توان از پیامدهای این زندگی جدید دانست. بازار مسکن به عنوان یکی از بازارهای پر سود موجب رشد و برخاستن جماعت «بساز و بفروش»ها شده است و این یعنی پایین آمدن کیفیت محل سکونت، کم شدن مساحت و ... که بدون تردید تاثیر بسیار بدی روی فرهنگ جامعه گذاشته است. این پروژه با هدف فراهم کردن نقشه‌ی بهینه ساختمان از جهات عملکردی انجام شده است و البته تا رسیدن به این مقصود فاصله‌ی بسیار زیادی دارد. در واقع ورودی نرم‌افزار تهیه شده در این پروژه قیدهای ساختمان از نظر طراح آن و خروجی نقشه‌ی ساختمان است.

«تولید نقشه‌ی بهینه‌ی ساختمان» جزء مسائل بهینه‌سازی محسوب می‌شود و راه حل آن کاملا وابسته به نحوه مدل‌سازی ساختمان است. در این پروژه ارائه‌ی ساختمان به گونه‌ای انجام گرفته که مساله با روشهای «پردازش تکاملی» قابل حل باشد. در ادامه پس از ارائه توضیح مختصری در مورد محاسبات تکاملی از روی کتاب «مقدمه‌ای بر محاسبات تکاملی»\cite{eiben_evolutionary_computing}، به تعریف مساله و بیان پاسخ داده شده به آن می‌پردازیم.

\section{محاسبات تکاملی}
حل مساله توسط رایانه به روشهای مختلفی ممکن است. جستجو به روش آزمون و خطا یکی از روشهای پرکاربرد در این زمینه است. ایده‌ی اصلی در این روش، شروع با تعدادی پاسخ و ارتقای تدریجی آنها است. اجرای چنین رویه‌ای، با تعریف فضای جستجو و نحوه‌ی ارزش‌گزاری پاسخها شروع می‌شود و فرایند ارتقا به شکلهای بسیار متنوع انجام می‌شود. محاسبات تکاملی با الگوگیری از نظریه‌ی تکامل در طبیعت، فرایند ارتقا را به انتخاب طبیعی و یا همان تنازع برای بقا، واگذار می‌کند.

فرایند تکامل با یک نسل اولیه آغاز می‌شود که به طور اتفاقی ایجاد شده است. اعمال عملگرهای مربوط به تولید فرزند از روی نسل موجود، منجر به تولید مجموعه‌ای از فرزندان می‌شود که اگر شایسته باشند، می‌توانند جای افراد ناشایست را در نسل کنونی بگیرند و به این ترتیب نسل جدید، مطابق قضاوت تابع ارزش‌گزاری، نسبت به نسل پیشین تکامل یافته است.

الگوریتم‌های بسیار زیادی برای انجام این فرایند ایجاد شده‌اند که تمایز میان آنها ناشی از نحوه‌ی مواجهه آنها با مفاهیم زیر است. واژه‌هایی را که در ادامه مورد بررسی قرار می‌گیرند، می‌توان به نوعی کلیدواژه‌های توصیف یک فرایند تکاملی خواند:

\paragraph{ارائه}
گام اول در تعریف یک فرایند تکامل، انتقال مفاهیم دنیای واقع به فضای حل مساله است. برای این منظور سعی می‌کنیم ویژگی‌های موجود در پاسخی را که با این فرایند به دنبال آن می‌گردیم، در قالب یک ژنوم ارائه کنیم. این ژنوم دنباله‌ای از مقادیر است که می‌تواند به صورت دودویی یا حقیقی باشند. باید توجه کنیم که این ژنوم همه‌ی اطلاعات مورد ارزیابی را برای تعیین یک پاسخ خوب به همراه داشته باشد و ارتقای این ژنوم به معنی ارتقای ارزشمندی در پاسخ مورد جستجو باشد.

\paragraph{تابع ارزیابی}
تابع ارزیابی نمایانگر ارزش یک ژنوم است و این ارزش تابعی است از ارزشی که به پاسخ متناظر با این ژنوم اختصاص می‌دهیم. ارتقا و تکامل در این فرایند، دقیقا به معنی بالا (یا پایین) رفتن مقدار این تابع است. از این تابع به عنوان تابع هدف هم یاد می‌کنند که به طور مشخص، مفهوم تلاش برای رسیدن به مقدار بهینه‌ی آن را نشان می‌دهد.

\paragraph{جمعیت}
از این عبارت برای توصیف تعدادی از افراد\LTRfootnote{Individuals} و یا همان مجموعه‌ای از ژنوم‌ها استفاده می‌کنیم. تعداد افراد موجود در یک جمعیت ثابت است و در ابتدای فرایند تعیین می‌شود. جمعیت در فرایند تکامل همان واحدی است که ارتقا می‌یابد و می‌توان گفت هدف فرایند تکامل تولید یک جمعیت خوب است و نه یک فرد خوب. در فرایند تکامل بعضی از رویه‌ها و حتی معیارها روی جمعیت تعریف می‌شوند. برای نمونه انتظار ما از فرایند تکامل، تولید یک جمعیت از پاسخهای گوناگون است و برای سنجش این گوناگونی، روشهایی مثل تفاوت میان ارزشمندی‌ها و یا تفاوت میان ژنوم‌ها مورد استفاده قرار می‌گیرند.

\paragraph{انتخاب والد}
برای رسیدن به جمعیت‌های بهتر باید فرزندان بهتری تولید کنیم و این هدف با انتخاب والدهای مناسب محقق می‌شود. انتخاب والد معمولا به شکل احتمالی انجام می‌شود و افراد بهتر، شانس بیشتری برای انتخاب شدن دارند. به این ترتیب شانس باقی ماندن ویژگی‌های تولید شده در فرزندان بیشتر می‌شود و جستجو با وسعت بیشتری انجام می‌شود.

\paragraph{عملگرهای تغییر}
این عملگرها وظیفه‌ی تولید فرزند را بر عهده دارند و می‌توان آنها را گام‌های جستجو نامید. عملگرهای تغییر با توجه به تعداد ورودی‌هایشان به دو دسته تقسیم می‌شوند:

\subparagraph{جهش}
عملگر جهش یک ورودی و یک خروجی دارد. در واقع این عملگر، تغییر مختصری را به صورت احتمالی روی ژنوم اعمال می‌کند. در بعضی از انواع الگوریتم‌ها این عملگر تمام نقش جستجو را بر عهده دارد و در مقابل بعضی از الگوریتم‌ها هیچ استفاده‌ای از آن نمی‌کنند. عملگر جهش در واقع برای ایجاد یک تغییر قابل توجه در ژنوم ایجاد شده و از نظر تئوری دستیابی به هر پاسخی در فضای جستجو را ممکن می‌کند. این عملگر وابستگی زیادی به نوع داده دارد. برای نمونه جهش در رشته‌ای از بیت‌ها به معنی تغییر یک ژن از 0 به 1 یا از 1 به 0 است، در حالی که در مساله‌ای مثل هشت وزیر باید جای وزیرها را با هم عوض شود.

\subparagraph{ترکیب}
عملگر ترکیب برای تولید فرزند یا فرزندانی با ویژگی‌های به ارث رسیده از دو والد، طراحی شده است. این عملگر نیز برای انتخاب بخشهای مختلف فرزند از دو والد، به شکل احتمالی عمل می‌کند. استفاده از عملگر ترکیب روی چند والد نیز ممکن است و در این حالت هر ویژگی فرزند ممکن است از والدی جدید انتخاب شود. باید توجه داشت که دلیل استفاده از این عملگر، قابلیت آن برای انتقال ویژگی‌های خوب از والدین منتخب است و این انتقال وابستگی زیادی به نحوه تعریف ژنوم دارد. به عبارتی هرچه استقلال ژن‌ها برای توصیف ویژگی‌ها از همدیگر بیشتر باشد، امکان انتقال ویژگی‌های مثبت بیشتر می‌شود. برای نمونه اگر رنگ چشم انسان تنها در یک عدد از ژنوم خلاصه شود، رنگ چشم مطلوب به آسانی به ارث می‌رسد در حالی که اگر اجزای رنگ در فضای رنگی RGB هر کدام یک عدد باشند، امکان به ارث رسیدن رنگ چشم مطلوب بسیار کاهش می‌یابد.

\paragraph{جایگزینی}
پس از تولید فرزندان از والدهای انتخاب‌شده، باید جمعیت جدید که همان نسل تکامل یافته است، ایجاد شود. برای انجام این کار، تعدادی از فرزندان ایجاد شده باید جایگزین افراد نسل قبل شوند. این جایگزینی با توجه به میزان ارزشمندی فرزندان و والدها انجام می‌شود. البته عواملی مانند سن والدها هم معمولا مورد توجه قرار می‌گیرند. این مرحله می‌تواند به صورت احتمالی و یا قطعی انجام شود و از انواع رایج آن مرتب‌سازی همه‌ی پاسخها و انتخاب نسل بعد از میان بهترین‌ها است.

\paragraph{آغاز}
جمعیت اولیه که از هیچ نسلی ایجاد نشده‌اند باید به شکلی تشکیل شود. بیشتر الگوریتم‌ها تولید این جمعیت را با در نظر گرفتن قیدهای مساله، به صورت کاملا احتمالی انجام می‌دهند. البته جمعیت آغازین می‌تواند به شکل ابتکاری و با هدف ایجاد گرایش در پاسخ‌ها تولید شود ولی بحثهای زیادی در نقد استفاده از این روشها وجود دارد.

\paragraph{شرط خاتمه}
فرایند تکامل باید به شکلی خاتمه یابد. رسیدن به مرز مشخصی از ارزشمندی یا حداقل نزدیک شدن به آن، می‌تواند معیار خوبی برای توقف باشد. اما با توجه به احتمالی بودن دستیابی به پاسخ، تضمینی برای رسیدن به مرز مورد نظر وجود ندارد و ممکن است در این حالت الگوریتم هیچ وقت متوقف نشود. به همین دلیل معیارهایی مثل حداکثر زمان استفاده از پردازنده، حداکثر تعداد اجرای تابع ارزیابی، ثابت ماندن میزان ارزشمندی طی نسلها و یا کاهش میزان گوناگونی در جمعیت، برای مطمئن شدن از توقف فرایند تعریف می‌شوند. 

پس از آشنایی با واژه‌ها و مفاهیم محاسبات تکاملی، در ادامه به توصیف الگوریتم‌های مورد استفاده در این پروژه می‌پردازیم.

\subsection{الگوریتم ژنتیک}
نام الگوریتم ژنتیک تا حد زیادی با فرایند تکامل گره خورده است. این الگوریتم که می‌توان آن را ساده‌ترین شکل تکامل دانست، با همان شاخصهای مطرح شده توصیف می‌شود. پس انتظار ما بیان ساده‌ترین شکل اجرای مراحل گفته شده در یک قالب یک الگوریتم کامل است و شکلهای پیچیده‌تر این مراحل در قالب الگوریتم‌های بعدی عرضه می‌شوند.

\subsubsection{ارائه}
همانطور که بیان شد، ایجاد فرایند تکامل با مشخص شدن نحوه ارائه مشخص می‌شود و نحوه ارائه رابطه‌ی مستقیمی با دستیابی به پاسخ و کیفیت آن دارد. نمایش ویژگی‌ها در این حالت با استفاده از ۰ و ۱ ها انجام می‌شود. بعضی از ویژگی‌ها ذاتا به این حالت هستند ولی برای نمایش ویژگی‌های عددی در این حالت می‌توان از نمایش دودویی آنها استفاده کرد. البته باید توجه داشت که استفاده از نحوه‌ی ارائه‌ی صحیح و یا حقیقی به پاسخهای بهتری منجر می‌شود.

همه‌ی مفاهیمی که به صورت انتخاب میان چند گزینه قابل ارائه هستند را می‌توان با استفاده از اعداد صحیح نمایش داد که قالب دیگری برای ارائه هستند. برای نمایش کمیت‌های پیوسته نیز باید از نمایش حقیقی استفاده کنیم که عملگرهای مختص خود را دارند.

پاسخ بعضی از مسائل در ترتیب قرار گیری اعداد توصیف‌کننده جواب است. مثلا وقتی مساله زمان‌بندی کارهای حل می‌کنیم، به دنبال ترتیب اجرای کارها می‌گردیم. در چنین مسائلی نحوه‌ی ارائه عوض نمی‌شود ولی عملگرهای مربوط به تغییر آن باید به این نکته توجه داشته باشند.

\subsubsection{جهش}
همان‌طور که توضیح داده شد، عملگر جهش تغییر کوچکی در ژنوم یک پاسخ ایجاد کرده و تنها یک پاسخ جدید تولید می‌کند. نحوه‌ی انجام این تغییر کاملا وابسته به نوع ارائه مساله است. وقتی از نمایش دودویی استفاده می‌کنیم، روش تغییر ۰ به ۱ یا ۱ به ۰ مورد استفاده قرار می‌گیرد. در این حالت هر کدام از ژنها با احتمال مشخصی و مستقل از همدیگر امکان تغییر دارند. معمولا این احتمال طوری تعیین می‌شود که هر بار اجرای این عملگر به طور متوسط موجب تغییر یک ژن شود.

هنگامی که با اعداد صحیح کار می‌کنیم، با توجه به مشخص بودن محدوده عدد، تعداد پاسخها محدود است. جهش در اعداد صحیح می‌تواند به معنی مقدار دهی مجدد هر کدام از ژنها با احتمالی مشخص و با مقدار اتفاقی انجام گیرد. عملگر دیگری که می‌توان برای این نوع تعریف کرد، انجام تغییر اتفاقی در ژنهاست. بروز تغییر نیز به صورت تصادفی و با مقداری تصادفی صورت می‌گیرد. مقدار تغییر در این روش باید با توزیع احتمال مشخص تعیین شود و انتخاب هر توزیع نیازمند تعیین پارامترهای آن است. از این رو تنظیم این پارامترها از چالشهایی است که باید با آن دست و پنجه نرم کرد.

اگرچه نمایش ژنوم به صورت اعداد حقیقی، تعداد نامحدودی جواب را قابل دستیابی می‌کند، اما عملگر جهش برای آن دقیقا مشابه اعداد صحیح است. به این ترتیب هر ژن با احتمال مشخصی باید تغییر کند و میزان این تغییر از روی توزیع احتمال مشخصی بدست می‌آید. معمولا از توزیع گوسی برای تولید این مقدار در بازه‌ی ممکن برای ژن استفاده می‌کنند و مشکل تنظیم پارامترها نیز همچنان پا برجاست.

وقتی رسیدن به پاسخ با تغییر ترتیب قرارگیری ژنها ممکن است، عملگر جهش نیز همین وظیفه را برعهده دارد. برای انجام این کار می‌تواند جای دو ژن را به صورت اتفاقی با هم عوض کند و بخشی از ژنوم را انتخاب کرده و ژنهای آن را برعکس کند.

\subsubsection{ترکیب}
اشاره کردیم که عملگر ترکیب برای ایجاد فرزند از روی نسل گذشته طراحی شده است. از این عملگر انتظار انتقال ويژگی‌های خوب به نسل بعد را داریم و همچنین برای ایجاد گوناگونی در پاسخها از آن استفاده می‌کنیم. وقوع احتمالی این رویداد به معنی آن است که بعضی از مواقع اعمال این عملگر موجب ایجاد تغییر در والدها نمی‌شود. عملگر ترکیب نیز مانند عملگر جهش وابسته به نوع ارائه‌ی ژنوم شکل‌های گوناگونی دارد که در ادامه آنها را بررسی می‌کنیم.

ترکیب یک نقطه‌ای از انواع عملگر ترکیبی است که برای نمایش دودویی ژنوم مورد استفاده قرار می‌گیرد. در این عملگر، یک عدد به طور تصادفی انتخاب شده و ژنوم دو والد از روی آن نقطه با هم تعویض می‌شود. یعنی جای بخش قبل از عدد تصادفی در والد اول با همین بخش در والد دوم تعویض می‌شود و به این ترتیب دو فرزند بدست می‌آید. به همین ترتیب می‌توان این کار را با چند نقطه انجام داد تا ژنهای دو والد کاملا با هم ترکیب شوند. در این حالت چند نقطه به طور اتفاقی انتخاب شده و فاصله‌ی میان آنها در دو والد با هم عوض می‌شود.

\begin{figure}[h] \centerline{\includegraphics{NPointCrossover}} \caption{\label{fNPointCrossover}
 اجرای عملگر ترکیب چند نقطه‌ای
 } \end{figure}
 
وقتی از عملگر ترکیب چند نقطه‌ای استفاده می‌کنیم، احتمال اینکه دو ژن کنار هم در هر والد، در فرزند تولید شده نیز در کنار هم بمانند، زیاد است. در مقابل، شکل دیگری از عملگر ترکیب با عنوان ترکیب یکنواخت سعی می‌کند این مشکل را حل کند. در این عملگر هر دو ژن هم شماره در دو والد با احتمال مشخصی ممکن است جابجا شوند و به این ترتیب هر ژن فرزندان ممکن است از یکی از والدها به ارث رسیده باشد.

ترکیب ژنهای مشخص شده با اعداد صحیح نیز دقیقا مشابه ترکیب ژنهای دودویی است. اما برای ترکیب ژنهای اعداد حقیقی علاوه بر روشهای گفته شده، راه‌های دیگری نیز وجود دارد. شکلهای مختلف این عملگر با توجه به معتبر بودن همه‌ی اعداد در محدوده‌ی مجاز، به طور تصادفی از میانگین ژنهای هم شماره برای تولید ژن فرزند استفاده می‌کند. میانگین‌گیری می‌تواند روی یک یا چند ژن انجام شود و برای انجام این کار راه‌های مختلفی پیشنهاد شده است.

ترکیب ژنهایی که به دنبال ترتیب صحیح آنها هستیم از حالت‌های دیگر مشکل‌تر است؛ چراکه ترکیب‌های گفته شده موجب تکرار عناصر می‌شوند و ژنوم‌های نامعتبر ایجاد می‌کنند. گروهی از راه‌های پیشنهادی برای حل این مشکل، ابتدا از روشهای گفته شده استفاده می‌کنند و بعد سعی می‌کنند فرزندان نامعتبر ایجاد شده را به‌گونه‌ای اصلاح کنند. اگرچه الگوریتم‌هایی هم پیشنهاد شده که تلاش در ایجاد فرزندان معتبر به طور مستقیم دارند. نکته‌ی مشترک در همه‌ی این روشها، تاکید آنها بر وقوع ارث‌بری است، در واقع فرزندان ایجاد شده باید ترتیب و یا مجاورت‌ها را به گونه‌ای از والد‌ها ارث ببرند.

عملگر ترکیب می‌تواند روی چند والد اجرا شود و چند فرزند تولید کند. شکل‌های متنوعی از این حالت نیز تا کنون پیشنهاد شده است ولی استفاده از این شیوه خیلی مرسوم نیست. برای انجام چنین کاری می‌توان هر ویژگی از هر فرزند را با احتمال مشخصی از یکی از والدها انتخاب کرد و یا میان از ژنهای پرتکرار یا نادر والدین برای تولید فرزند استفاده کرد.

\subsubsection{انتخاب والد}
برای تکامل یافتن نسل‌ها باید فرزندان خوبی تولید کنیم و تولید فرزند خوب نیازمند اجرای عملگرهای جهش و ترکیب روی والدهای خوب است. میزان شایستگی والدها را با تابع ارزیابی اندازه می‌گیریم و چون همه فرصت والد شدن را ندارند، بخشی از آنها را به صورت احتمالی انتخاب می‌کنیم. توزیع این احتمال بی‌تردید با شایستگی والدها رابطه دارد، اما این رابطه را می‌توان به شکلهای مختلف تعریف کرد.

در بعضی از روشها احتمال انتخاب شدن مستقیما با میزان شایستگی ارتباط دارد؛‌ اگرچه وجود دارند روشهایی که تنها رتبه‌ی فرد در میان جمعیت موثر در احتمال انتخاب اوست. میزان تاثیر شایستگی و یا رتبه نیز می‌تواند به صورت خطی، نمایی و یا شکلهای دیگر اعمال شود که بحث مفصل در مورد آنها در این مرور گذرا نمی‌گنجد.

برای انتخاب والد بر اساس احتمال مشخص شده می‌توانیم از الگوریتم ساده‌ای مثل Roulette Wheel استفاده کنیم. این الگوریتم در هر اجرا یک فرد را انتخاب می‌کند و احتمال انتخاب شدن هر فرد توسط آن برابر احتمال انتخاب نسبت داده شده به آن است. روشهای بهتری نیز برای انجام این کار پیشنهاد شده‌اند. برای نمونه Tournament Selection نام الگوریتمی است که بدون نیاز به مشاهده‌ی احتمال انتخاب همه‌ی اعضا و در زمان کمتر انتخاب مناسبی را با توجه به احتمال‌های نسبت داده شده انجام می‌دهد. در هر نوبت اجرای این الگوریتم، تعدادی از افراد با احتمال مساوی انتخاب شده، به صورت مقایسه‌ای رتبه‌بندی می‌شوند. سپس از میان گروه انتخاب شده، بهترین فرد به شکل قطعی و یا احتمالی برگزیده می‌شود.   

\subsubsection{جایگزینی}
در این مرحله باید از میان فرزندان تولید شده و والدها، نسل جدیدی را انتخاب کنیم که می‌توان گفت تکامل یافته است. می‌توانیم همه‌ی والدها را کنار گذاشته و نسل بعد را از میان فرزندان انتخاب کنیم و یا فقط والدهای کم‌ارزش را با فرزندان شایسته جایگزین کنیم. در هر حال روشن است که از میان فرزندان و والدها باید به اندازه‌ی نسل اولیه انتخاب کنیم تا جمعیت جدید برای تکرار فرایند تکامل تشکیل شود.

می‌توانیم به صورت اتفاقی والدهایی را که حذف می‌شوند، انتخاب کنیم و یا به هر فرد اجازه بدهیم تعداد نسل مشخصی زنده باشد؛ اگر به هر فرد تنها یک نسل اجازه‌ی زندگی بدهیم در واقع همه‌ی والدها را کنار گذاشته و از فرزندان استفاده کرده‌ایم.

انتخاب جمعیت جایگزین با روش گزینش (با استفاده از از روشهای مطرح شده برای انتخاب والد) نیز ممکن است. همچنین روش‌های حذف افراد کم‌ارزش و یا نگهداری افراد شایسته نیز می‌توانند مورد استفاده قرار گیرند. اگرچه به نظر می‌رسد با ترکیب این روش‌ها پاسخهای مناسب‌تری تولید می‌شود.

\subsection{استراتژی تکاملی}
الگوریتم استراتژی تکاملی برای مسائل بهینه‌سازی در فضای پیوسته استفاده می‌شود و ویژگی اصلی آن انطباق‌پذیری با مساله است. انطابق با مساله به معنی قرار گرفتن پارامترهای اجرای الگوریتم در ژنوم و تکامل یافتن آنها به همراه ژنها است. در فرایند تکامل پارامترهای بسیار زیادی وجود دارد که می‌توان همه‌ی آنها را در ژنوم قرار داد، اما صورت شناخته شده و البته آزمایش شده‌ی  این روش قرار دادن پارامترهای عملگر جهش در ژنوم است. برای تکامل ژنوم‌ها تابع ارزیابی را به عنوان ملاک انتخاب ژنوم خوب معرفی کردیم، این تابع در تکامل پارامترهای اجرا نیز به ما کمک می‌کند. برای نمونه می‌توانیم از نسبت فرزندانی که با عملگر جهش ایجاد شده‌اند و بهتر از والدها هستند را به عنوان معیاری برای اصلاح پارامترهای اجرا در نظر بگیریم. به این ترتیب وقتی نسبت میان فرزندان خوب و والدها بالاست باید این وضع را حفظ کنیم و طول گام جهش را کاهش دهیم و در مقابل وقتی فرزندان خوب کمتر از انتظار ما هستند می‌توانیم طول گام را افزایش داده و احتمال کشف پاسخهای دورتر را بیشتر کنیم.

\subsubsection{جهش}
عملگر جهش را می‌توان اصلی‌ترین  بخش الگوریتم استراتژی تکاملی دانست. معمولا برای این عملگر یک توزیع گوسی در نظر می‌گیریم و از فرایند تکامل انتظار داریم، پارامترهای آن را تنظیم کند. پارامتر میانگین باید برابر صفر باشد تا جستجو در یک جهت انجام نشود. پارامتر دیگر این توزیع انحراف معیار است که در عمل می‌توان آن را طول گام جهش دانست. 

طول گام را می‌توانیم برای هر ژن به صورت جداگانه قرار دهیم و یا حتی از یک طول گام برای همه‌ی ژنها استفاده کنیم، قرار دادن یک طول که حجم محاسبات را بسیار کاهش می‌دهد در خیلی از موارد تفاوت چندانی با گامهای متمایز برای هر ژن ندارد. کامل‌ترین شکل انطباق با مساله و به عبارتی یادگیری فضای حالت، استفاده از جهش همبسته \LTRfootnote{Correlated Mutation} است که در آن باید علاوه بر طول گامهای جداگانه، به ازای هر دو ژن یک پارامتر نمایانگر میزان همبستگی میان آنها به ژنوم اضافه شود.

در شکلهای زیر می‌توانیم آزادی عملی را که هر کدام از این روشها برای ما فراهم می‌کنند، مشاهده کنیم. در این شکلها نقطه‌ی سیاه نمایانگر پاسخ کنونی در فضای دو بعدی (دو ژن) و بیضی دور آن پاسخهای محتمل در گام بعدی را نمایش می‌دهد.

\begin{figure}[h] \centerline{\includegraphics{MutationStep}} \caption{\label{fMutationStep}
 عملگر جهش با یک پارامتر طول گام
 } \end{figure}
 
\begin{figure}[h] \centerline{\includegraphics{MutationNStep}} \caption{\label{fMutationNStep}
 عملگر جهش با پارامترهای طول گام جداگانه برای هر ژن
 } \end{figure}
 
\begin{figure}[h] \centerline{\includegraphics{CorrelatedMutation}} \caption{\label{fCorrelatedMutation}
 عملگر جهش همبسته با پارامترهای طول گام برای هر ژن
 } \end{figure}
 
  البته باید توجه داشت که اگرچه این عملگرها آزادی عمل ما را زیاد می‌کنند، اما یادگیری آنها نیز به سختی یادگیری پاسخ واقعی است، از این رو پیچیدگی محاسباتی را به شدت افزایش می‌دهند و در بسیاری از مسائل نیز کمک زیادی به حل نمی‌کنند.

\subsubsection{ترکیب}
عملگر ترکیب در استراتژی تکاملی معمولا به صورت کلی انجام می‌شود که به معنی به ارث رسیدن هر ژن از دو والد تصادفی است. به این ترتیب همه‌ی فرزندان را می‌توان فرزند همه‌ی والدها دانست. البته شکلهای مختلفی از پیاده‌سازی این عملگر وجود دارد اما یکی از روشهای مرسوم پیاده‌سازی آن استفاده از روش انتخاب ژن برای ترکیب ژنهای معمولی و روش میانگین‌گیری برای ژنهای مربوط به اجرای الگوریتم است. این انتخابهای مشخص از میان گزینه‌های مختلف، با هدف دستیابی به گوناگونی در پاسخها انجام شده و در آزمایشهای تجربی بدست آمده است.

\subsubsection{جایگزینی}
انتخاب نسل بعد از میان ژنوم‌ها در این الگوریتم معمولا به صورت نادیده گرفتن والدها و جایگزینی فرزندان انجام می‌شود. این انتخاب کاملا به صورت قطعی و بر اساس رتبه‌ی آنها انجام می‌شود. این روش موجب می‌شود به آسانی از نقاط بهینه‌ی موضعی خارج شویم. حفظ ژنوم‌های نسل قبل که به نظر شایسته می‌شوند، موجب می‌شود پارامترهای اجرا به خوبی تکامل نیابند و در واقع خوب بودن ژن‌ها در آنها، ضعف پارامترهای اجرا برای آنها می‌پوشاند.

\subsection{روشهای چند هدفه}
پیش‌تر در مورد تابع ارزیابی و نقش آن در مراحل مختلف فرایند تکامل صحبت کردیم. تصور ما از تابع ارزیابی، تابعی است که ژنوم را ورودی گرفته و میزان شایستگی آن را با یک کمیت توصیف می‌کند. سپس از این میزان شایستگی در انتخاب والد و جایگزینی استفاده می‌کنیم. معمولا پاسخهای ما از جنبه‌های مختلفی بررسی می‌شوند که حتی ممکن است با هم متناقض هم باشند. قضاوت میان دو پاسخ از نگاه یک جنبه یا ویژگی پیچیده نیست، اما ما نیاز داریم شایستگی پاسخ را به صورت یک عدد بیان کنیم. واضح‌ترین راه برای دستیابی به این هدف، کمی کردن همه‌ی ويژگی‌ها و جمع کردن مقدار آنها است. در این روش برای وارد کردن اولویت میان ویژگی‌ها می‌توانیم این جمع را به صورت وزن‌دار انجام دهیم که در این صورت حتما با چالش میزان وزن‌ها روبرو خواهیم شد.

\subsubsection{برتری}
اگر بخواهیم از تبدیل همه‌ی ويژگی‌ها به یک عدد اجتناب کنیم باید برای بررسی برتری میان دو پاسخ، همه‌ی آنها را با هم در نظر بگیریم. وقتی یک پاسخ در همه‌ی ويژگی‌ها از پاسخ دیگر بهتر است، مسلما آن را پاسخ برتر می‌نامیم. اما وقتی این شرایط وجود ندارد باید در مورد قضاوت میان پاسخها تصمیم بگیریم. در ادامه بعضی از روشهای مواجهه با این مساله را بررسی می‌کنیم:
\begin{itemize}
\item
تقسیم جمعیت به بخشهای مختلف و استفاده از یک معیار برای هر کدام از این بخشها در مرحله جایگزینی
\item
شمردن تعداد پاسخهای بدتر از یک پاسخ برای محاسبه‌ی میزان شایستگی آن
\item
روش دیگری نیز پیشنهاد شده که با استفاده از انتخاب رقابتی سعی می‌کند، مجموعه برگزیده را انتخاب کند. این الگوریتم برای مقایسه ابتدا برتری میان دو پاسخ را می‌سنجد و اگر هیچ کدام برتر نبود پاسخی را انتخاب می‌کند که موجب می‌شود گوناگونی مجموعه برگزیده، افزایش یابد.
\item
روشی با نام NSGA سعی می‌کند جمعیت را به گروه‌های برتری، تقسیم کند تا بتواند به این گروه‌ها میزان شایستگی نسبت دهد. در هر بار تکرار این الگوریتم، پاسخهایی که هیچ پاسخ برتری از آنها وجود ندارد و قبلا به گروهی تعلق نگرفته‌اند، انتخاب شده و در یک گروه قرار داده می‌شوند. به این ترتیب بهترین گروه در ابتدا و بدترین گروه در آخرین تکرار مشخص می‌شود. میزان شایستگی هر پاسخ در این الگوریتم برابر تعداد اعضای گروه‌های بدتر از آن است. 
\end{itemize}
الگوریتم‌های زیادی برای این منظور پیشنهاد شده که هر کدام سعی کرده‌اند انتخاب گزینشی و همچنین رسیدن به گوناگونی در پاسخ را به شکلهای مختلف محقق کنند که بررسی آنها از عهده‌ی این مرور اجمالی خارج است.

 \subsubsection{دستیابی به گوناگونی}
از مشکلات اصلی فرایندهای تکاملی رسیدن به گوناگونی است. در واقع ما همیشه باید میان سرعت میل به پاسخ خوب و دستیابی به پاسخهای گوناگون تعادل برقرار کنیم. راه‌های متعددی برای رسیدن به این منظور پیشنهاد شده است که در دو دسته اصلی تقسیم‌بندی می‌شوند:

در روشهای ضمنی سعی می‌کنیم عوامل محیطی را طوری تنظیم کنیم که گوناگونی مورد نظر محقق شود، در ادامه بعضی از این روشها فهرست شده‌اند:
\begin{itemize}
\item
اجرای مکرر یک الگوریتم و گزینش پاسخهای خوب
\item
اجرای موازی چند الگوریتم و انتقال منظم افراد میان آنها
\item
جداسازی منطقی بخشی از جمعیت به عنوان گونه خاص و محدود کردن اجرای عملگر ترکیب به استفاده از افراد یک گونه به عنوان ورودی 
\end{itemize}

در دسته‌ی دیگری از این روشها، ما مستقیما میزان گوناگونی میان پاسخها را اندازه‌گیری کرده و از این مقدار برای بالا بردن آن در نسلهای بعد استفاده می‌کنیم که در ادامه به دو مورد آن اشاره می‌کنیم:
\begin{itemize}
\item
جلوگیری از جمع شدن پاسخها در یک نقطه‌ی بهینه موضعی با تغییر میزان شایستگی افراد مشابه
\item
جایگزینی افراد مشابه با استفاده از فرزندان برگزیده
\end{itemize}

\subsection{روشهای ترکیبی}
فرایندهای تکاملی برای جستجو در فضای حالت، الگوریتم‌های خوبی هستند، اما برای رسیدن به مجموعه جواب عالی و البته گوناگون نمی‌توان توقع زیادی از آنها داشت. چراکه همیشه در این الگوریتم‌ها باید تعادلی میان عمق جستجو و وسعت آن برقرار کنیم. به بیان دیگر می‌توان گفت فرایندهای تکاملی نقاط بهینه‌ی موضعی را بسیار سریع و آسان پیدا می‌کنند اما در پیدا کردن بهترین پاسخها عملکرد قابل اطمینانی ندارند. در بسیاری از مسائل، استفاده از الگوریتم‌های جستجوی موضعی در بخشهایی از فرایند تکامل، می‌تواند کیفیت پاسخها را به بهای افزایش محاسبات، بالا ببرد.

\subsubsection{الگوریتم جستجوی موضعی}
فضای جستجو در مسائل بهینه‌سازی معمولا پر از نقاط بهینه‌ی موضعی است که می‌توان آنها را در فضای ۲ بعدی به صورت قله برای تپه‌های پاسخ تصور کرد. الگوریتم‌های جستجوی موضعی سعی می‌کنند، نقطه‌ی پاسخ را از این تپه‌ها بالا برده و آن را مرحله به مرحله ارتقا دهند. انواع زیادی از این الگوریتم‌ها تا کنون پیشنهاد شده که همه‌ی آنها برای ارتقای جواب به صورت گام به گام و در حالت قطعی یا احتمالی تلاش می‌کنند.
 
الگوریتم‌های جستجوی موضعی برای ارتقای پاسخ، به همسایه‌های آن نگاه کرده و یکی از همسایه‌ها را به عنوان پاسخ جدید انتخاب می‌کنند. تعریف همسایگی میان دو پاسخ کامل وابسته به فضای جستجو و راه حل ما است. وقتی در فضای گسسته قرار داریم تعریف همسایگی خیلی پیچیده نیست، اما در فضای پیوسته نیاز به استفاده از توزیع احتمال گام‌ها داریم. انتخاب یک همسایه به عنوان پاسخ بعدی نیز به شکل‌های مختلفی انجام می‌شود. می‌توانیم به محض رسیدن به یک همسایه‌ی بهتر آن را انتخاب کنیم و یا در مقابل می‌توانیم ابتدا همه و یا تعداد قابل توجهی همسایه را تولید کرده و بعد با توزیع احتمالی که تابع میزان شایستگی آنهاست، همسایه‌ی مورد نظر را انتخاب کنیم. چالش بعدی عمق این جستجو است که می‌تواند بسیار کم باشد؛ خصوصا وقتی انتظار ما از این الگوریتم، تنها ارتقای پاسخ است و قرار نیست همه‌ی وظیفه‌ی دستیابی به جواب مناسب را بر عهده‌ی آن قرار دهیم.

\subsubsection{چالشها}
استفاده از جستجوی موضعی در بخشهای مختلف فرایند تکامل ممکن است. می‌توانیم از این جستجو بعد یا قبل از اعمال عملگرها استفاده کنیم، یا حتی می‌توانیم قبل از شروع فرایند تکامل، جمعیت اولیه را با این روش ارتقا دهیم. البته تحقیقات انجام شده در این زمینه نشان می‌دهد که آغاز فرایند با چنین جمعیتی، مانع از بررسی دقیق فضای جستجو می‌شود و شاید استفاده از چند نمونه‌ی ارتقا یافته در میان جمعیت، گزینه‌ی بهتری باشد.

استفاده از جمعیتی که دیگر نمی‌توان آن را تصادفی نامید، موجب تسریع فرایند تکامل می‌شود؛ چراکه نقاط کم اهمیت با نسبت پایین‌تری مورد بررسی قرار می‌گیرند. به این ترتیب با استفاده‌ی آگاهانه از این فرصت می‌توان جمعیت را به سمت پیدا کردن جواب مناسب، هدایت کرد. قضاوت در مورد خوب یا بد بودن استفاده از این روش، در هر مساله و متناسب با نحوه‌ی اعمال آن، متفاوت است.

چالش مربوط به عمق جستجو نیز وضع مشابهی دارد. اگر به جستجوی موضعی اجازه دهیم پاسخ را کاملا به حالت بهینه‌ی موضعی نزدیک کند، عملا گوناگون پاسخها مورد تهدید قرار می‌گیرد و در مقابل کیفیت جوابها بالا می‌رود. به همین دلیل، ترکیب چنین روشی با روشهای مستقیم بازیابی گوناگونی منجر به نتایج بهتری می‌شود.

\section{تعریف مساله}
کاربر نرم‌افزار علاقه دارد با فشار دادن یک دکمه نقشه‌ی ساختمان را با جزئیات کامل دریافت کند. افق این پروژه نیز به همین شکل ترسیم شده است؛ اما آغاز راه باید کمی ساده‌تر تصور شود. در این مرحله از سیر پروژه، زمین ساختمان به صورت یک مستطیل در نظر گرفته شده و کاربر باید ابعاد آن را مشخص کند. همچنین نرم‌افزار هیچ شناختی از اتاقها ندارد و کاربر باید مساحت و یا ابعاد هر کدام از آنها را تعیین کند. قرار دادن اتاقهای مستطیل‌شکل در فضا موجب به وجود آمدن فضاهای خالی می‌شود؛ فضای دسترسی نامی است که برای این فضاهای باقیمانده در نظر گرفته شده و قابل استفاده کردن آنها از اهداف چالش برانگیز پروژه است. باید به محدودیتهای کنونی پروژه، فرض مسکن بودن ساختمان را نیز اضافه کرد. در واقع درک نرم‌افزار از فضای دسترسی، یک هال بزرگ متصل به حداقل راهروهای ممکن برای ایجاد دسترسی به اتاقها است.

خانه‌ی مطلوبی که قرار است به عنوان خروجی ارائه شود باید قابل سکونت باشد؛ یعنی علاوه بر انطباق با خواسته‌های کاربر از نظر ابعاد، دسترسی به همه‌ی اتاقهای آن ممکن باشد. البته کاربر وظیفه‌ی انتخاب نحوه دسترسی را بر عهده دارد و می‌تواند تعیین کند که مثلا مستطیل مربوط به آسانسور تنها از مستطیل راه‌پله قابل دستیابی است.

آخرین وظیفه‌ی کاربر تعیین نوع نورگیری ساختمان در ضلعهای مختلف آن است. شناخت نحوه گرفتن نور توسط ساختمان و ورودی گرفتن اولویت نوری میان اتاقها از کاربر به نرم‌افزار امکان طراحی خانه‌ای با الگوی نورگیری مناسب را می‌دهد. امید است که در نگارشهای بعدی نرم‌افزار قابلیت تصمیم‌گیری در مورد نیاز خانه به نورگیر و مشخصات آن را کسب کند. ارزیابی یک ساختمان و به طور خاص یک خانه جنبه‌های بی‌شماری دارد که حضور در مراحل آغازین، بهانه‌ای قابل قبول برای صرف نظر کردن از آنهاست.

\section{نحوه بیان مساله}
حل این مساله با فرایند تکامل نیازمند توصیف پاسخ آن در قالب تعداد محدودی عدد حقیقی است که به مجموعه‌ی آنها ژنوم می‌گوییم. معنی این اعداد هرچه از هم مستقل‌تر باشد، جستجو در فضای حل مساله آسان‌تر انجام می‌گیرد؛ از این‌رو هر اتاق ساختمان را با چهار مؤلفه فاصله افقی و عمودی از مبدا و طول و عرض آن نمایش می‌دهیم. با این نحوه‌ی ارائه اگر همه‌ی اعداد ژنوم مثبت باشند، می‌توان آن را ژنومی معتبر دانست. اگرچه این سطح از اعتبار تضمین نمی‌کند که اتاقها با هم تداخل نداشته باشند، اما می‌توانیم مطمئن باشیم که اتاقی با طول و عرض منفی نداریم.

\section{عملگرها}
عملگرهای فرایند تکامل باید با ژنومی که برای توصیف پاسخها استفاده می‌شود، سازگار باشند. بعضی از انواع عملگرها به طور عام طراحی شده‌اند و این پروژه نیز از آنها بی‌بهره نبوده است. اما علاوه بر عملگرهای عام، عملگرهایی نیز به طور خاص برای ژنوم توصیف کننده ساختمان تعریف شده‌اند. نکته‌ی مشترک در این عملگرها، نگاه به اتاقها با عبور از اعداد توصیف کننده‌ی آنهاست. در واقع عملگرهای عام به هر عدد موجود در ژنوم به طور مستقل نگاه می‌کنند در حالی که ما به دنبال عملگرهایی هستیم که در آنها اتاقها موضوعیت داشته باشند.

برای نمونه در نوع خاصی از عملگر ادغام هر ویژگی فرزند به طور احتمالی از یک والد انتخاب می‌شود. این عملگر با انگیزه‌ی ایجاد فرزندی با ویژگی‌های والدها طراحی شده و انتظار می‌رود فرزند مربوط به والدهای بهتر، بخشی از شایستگی‌های هر والد را به همراه داشته باشد. حتی در یکی از شکلهای اجرا، ممکن است تعداد زیادی والد همزمان برای تولید تعداد زیادی فرزند مورد استفاده قرار گیرند. تاثیر این عملگر روی ژنوم توصیف کننده ساختمان به نظر کمی متفاوت با هدف طراحی آن می‌رسد؛ چراکه شایسته بودن والد بیش از آنکه به هر عدد وابسته باشد، به هر اتاق (چهار عدد متوالی) وابسته است و احتمال بسیار زیادی وجود دارد که فرزند از هر دو والد شایستگی کمتری داشته باشد. این پدیده با بی‌اثر کردن عملگر ادغام، علاوه بر کند کردن فرایند تکامل، موجب کاهش گوناگونی در پاسخها و به عبارتی بروز همگرایی در آنها می‌شود. در توضیح این ادعا باید گفت که با کم‌رنگ شدن نقش عملگر ادغام، همه‌ی وظیفه‌ی ایجاد تنوع روی دوش عملگر جهش می‌افتد و پاسخهای نسبتا بد در مقابل پاسخهای تولید شده از جهش‌های مختلف یک جواب بهتر، حذف می‌شوند. در ادامه به عملگرهایی که برای این مساله خاص طراحی شده‌اند، توجه می‌کنیم و نتایج مربوط به این پدیده را در بخش نتایج مربوط به روشهای مختلف، مشاهده می‌کنیم.

\subsection{ادغام اتاقها}
این عملگر از دو والد که از مرحله انتخاب عبور کرده‌اند، دو فرزند ایجاد می‌کند. هر اتاق در هرکدام از فرزندها با احتمال مشخصی متعلق به یکی از دو والد است. برای نمونه ممکن است فرزند تولید شده آشپزخانه را از یک والد و اتاق خواب را از والد دیگر به ارث ببرد.

\subsection{جهش تعویض مکان دو اتاق}
این عملگر روی فرزندان حاصل از عملیات ادغام، اعمال می‌شود و همانطور که اشاره شد به معنی مجموعه‌ی اعدادی که یک اتاق را نمایش می‌دهند توجه دارد. این عملگر مرکز قرار گیری دو اتاق را که به طور اتفاقی انتخاب شده‌اند، با هم عوض می‌کند. در مراحل آغازین فرایند تکامل (زمانی که پاسخها نقصهای متعددی دارند) و همچنین هنگامی که شرطهای مربوط به ابعاد برای دو اتاق انتخاب شده مشابه هم است، تاثیر بهتری را می‌توان از چنین عملگری مشاهده کرد. 

\section{تابع ارزیابی}
از ژنوم صحبت کردیم و اینکه نقشه‌ی ساختمان را با تعدادی عدد حقیقی نمایش می‌دهیم. فرایند تکامل برای رسیدن به هدف نیاز به یک راهنما دارد و این راهنما باید نتایج فرایند را به سمت ساختمان هدایت کند. نقشه‌ی ساختمان ویژگی‌های زیادی باید باشد، تابع ارزیابی باید هر کدام از این ویژگی‌ها را با استفاده از معیاری کمّی بسنجد تا تحقق آنها در پاسخ ممکن باشد.

در این پروژه محدودیت زمانی مانع از تعریف معیارهای بسیار پیچیده برای ارزیابی ویژگی‌ها ساختمان شد. از این رو نتایج فرایند تکامل را نمی‌توان خانه‌های مناسبی برای زندگی دانست؛ اگرچه شباهت زیادی به آنها دارند و یا حتی در مواردی قابل سکونت هم هستند. برای نمونه ساختمانهای خروجی قابل اجرا هستند یعنی اتاقها با هم تداخل ندارند و حتی دیوار بین آنها هم مورد توجه قرار گرفته؛ اما روشن است که انتظار ما از خانه خیلی بیشتر از قابل اجرا بودن است.

بعضی از معیارها با استفاده از تحلیل هندسی هر اتاق و یا هر دو اتاق انجام می‌شوند. چنین معیارهایی معمولا ویژگی‌های ساده‌ای را مورد بررسی قرار می‌دهند و طبیعتا ابهام کمتری دارند. برای نمونه ما انتظار داریم ابعاد اتاق خواب در خانه مقادیر مشخصی باشد، معیار متناظر با این ويژگی مورد انتظار، به صورت سنجش مساحت هر اتاق به طور جداگانه تعریف می‌شود. اما بعضی از ویژگی‌ها نیاز به بحث و بررسی بیشتری دارند.

غیر از این معیارهای ساده، معیارهای دیگری هم وجود دارند که به فضای خالی میان اتاقها را ارزیابی می‌کنند. نحوه توصیف این فضا و محاسبه‌ی آن یکی از چالشهای این پروژه است که در توضیح بیشتری در مورد آن می‌دهیم.

\subsection{فضای دسترسی}
ارضای معیارهای مربوط به فضای خالی میان اتاقها، کاملا وابسته به تعریفی است که از این فضا ارئه می‌کنیم. در این پروژه تعریف فضا به صورت قرار دادن مستطیلهای فرضی در پاسخ صورت گرفته است. در واقع الگوریتمی ابتکاری برای قرار دادن بزرگترین مستطیلهای ممکن برای پوشاندن فضای خالی تعریف شده است. مستطیلهای بدست آمده از این الگوریتم ماده خام برای انجام ارزیابی‌های فضایی هستند. بزرگترین و متناسب‌ترین مستطیل از میان این مستطیلها به عنوان هال انتخاب می‌شود و بقیه نقش راهرو و پیش‌فضا را بازی می‌کنند. در تعریف پیش‌فضا باید گفت که ورودی بعضی از اتاقها مثل حمام بهتر است که در تماس مستقیم با فضای دسترسی اصلی نباشد. پوشش فضایی به گونه‌ای انجام می‌شود که فضاهای خرد انتخاب نشده و فقط فضاهای قابل استفاده انتخاب شوند.

\begin{figure}[h] \centerline{\includegraphics{AccessSpace}} \caption{\label{fAccessSpace}
 نمایش فضای دسترسی بین اتاقها
 } \end{figure}

\subsubsection{روش محاسبه فضای دسترسی}
فضای خالی میان اتاقها باید با بزرگترین مستطیلهای ممکن پوشانده شود. این مستطیلها می‌توانند روی هم قرار بگیرند ولی طول یا عرض آنها نباید کوچکتر از مقدار مشخصی باشد. برای پیدا کردن مستطیلهای پوشاننده، ابتدا شبکه‌ای از نقاط را روی صفحه قرار می‌دهیم و سعی می‌کنیم بزرگترین مستطیلی را که از هر نقطه عبور می‌کند، محاسبه کنیم. برای پیدا کردن بزرگترین مستطیل عبور کننده از یک نقطه، به فاصله‌ي آن نقطه تا مستطیلهای مجاور آن نگاه می‌کنیم و به این ترتیب سعی می‌کنیم طول و عرض مستطیل را پیدا کنیم.

در نهایت بزرگترین مستطیل از میان مستطیلهای مشخص شده را به عنوان فضای اصلی دسترسی تعیین می‌کنیم. این مستطیل در خانه‌ی مسکونی همان اتاق هال است و هر مستطیلی که در تماس با آن نباشد، مکانی غیر قابل دسترسی فرض شده و حذف می‌شود.

می‌توان گفت این روش به دنبال بررسی همه‌ی مستطیلهای ممکن برای پوشاندن فضای خالی است و قرار دادن شبکه‌ای از نقاط روی صفحه موجب می‌شود که مساله از فضای اعداد پیوسته به اعداد گسسته انتقال یابد. البته برای حل این مساله احتمالا راههای بسیار بهتری از آنچه که توضیح داده شد، وجود دارد. امید است که در آینده این روش مورد بازبینی و اصلاح قرار گیرد.

\subsection{معیارها}
در این بخش به دنبال مشخص کردن معیارهایی کمّی برای رسیدن به ویژگی‌های مطلوب ساختمان هستیم. بعضی از اهداف ما به صورت جریمه مطرح می‌شوند و مشخص می‌کنند که ساختمان باید چطور نباشد. در مقابل بعضی دیگر برای ساختمان امتیاز محسوب می‌شوند و البته بهتر بودن مقدار آنها به معنی بالاتر بودن کیفیت خانه است. به عبارت دیگر اگر ساختمان از نظر معیارهایی که به صورت امتیاز مطرح می‌شوند، ارزش کمی داشته باشد، باز هم قابل اجرا است ولی محل مناسبی برای استفاده نیست.

نکته‌ای که در تعریف معیارها مورد توجه قرار گرفته و روی آن بسیار تاکید می‌شود، تدریجی بودن اکتساب مزیت در آنها است. در واقع سعی بر آن است که مسیر مشخصی جلوی فرایند تکامل قرار گیرد تا پیمودن آن ممکن باشد. این ویژگی ضامن رسیدن فرایند به پاسخ است و نبودن آن موجب می‌شود که رسیدن به پاسخ کاملا به اقبال وابسته باشد. برای نمونه فرض کنید که به دنبال قرارگیری اتاق خاصی در مرکز خانه باشیم. برای ارزیابی پاسخهایی که این ویژگی در آنها برآورده نشده است، فاصله‌ی اتاق مورد نظر را تا مرکز خانه به عنوان جریمه در نظر می‌گیریم و فرایند تکامل کم‌کم اتاق را به محل مورد نظر ما می‌رساند. اگر این نگاه بر معیار ما حاکم نبود، فقط پاسخی که در آن اتاق در مرکز خانه قرار گرفته ارزشمند تلقی می‌شد و این یعنی فرایند تکامل ممکن است این پاسخ را پیدا نکند.

\subsubsection{تداخل}
نقشه‌ی خانه را می‌توان طوری توصیف کرد که تداخل اتاقها و یا خارج شدن اتاقها از محدوده ساختمان بی‌معنی باشد. اما در توصیفی که تاکنون از نقشه داشته‌ایم، احتمال وقوع این اتفاق کم نیست. از این رو جریمه‌ی تداخل را برای جلوگیری از آن تعریف می‌کنیم.

برای سنجش این معیار، میزان تداخل میان هر دو اتاق و هر اتاق با فضا خارج از محدوده نقشه را اندازه می‌گیریم. توجه کنید که منظور از میزان تداخل، مساحت مشترک میان دو اتاق نیست؛ چراکه استفاده از مساحت موجب بی‌ارزش شدن تداخل میان اتاقهای کوچک می‌شود. میزان تداخل برابر کمترین مقدار تغییر مکان لازم برای برطرف شدن تداخل میان دو اتاق است. به همین منظور فاصله‌ی عمودی و افقی خروج از حالت تداخل محاسبه شده و کمینه‌ی آنها به عنوان جریمه اعلام می‌شود.

\begin{figure}[h] \centerline{\includegraphics{Intersection}} \caption{\label{fIntersection}
 میزان تداخل میان دو اتاق
 } \end{figure}

\subsubsection{ابعاد}
برای یافتن ابعاد مناسب یک اتاق باید به سوالهای زیادی در مورد آن پاسخ دهیم. دلباز و بزرگ بودن اتاق مورد نظر ما است و یا برعکس هر چه کوچکتر باشد، فضای کمتری از خانه را هدر داده‌ایم. اگر در خانه از فرش استفاده می‌کنیم، آیا فضای اتاق با اندازه‌های استاندارد فرش سازگار است. فضای مورد نظر ما برای عبور طراحی شده و یا صحبت از مکانی برای زندگی و گذراندن وقت است. قرار است در این اتاق از تخت استفاده کنیم و یا ابعاد مبلمان را باید در نظر داشته باشیم. سوالهای بسیار زیادی در این بخش قابل طرح هستند و پاسخ آنها نیز قابل سنجش و اعمال است.

این کاربری‌ها برای تحقق نیاز دارند کمّی شوند. برای این کار دو روش «تعیین طول و عرض» و «تعیین مساحت» پیاده‌سازی شده‌اند که در ادامه به توضیح آنها می‌پردازیم. باید توجه کنیم که در هر دو روش، جریمه‌ها طوری تعیین شده که فضای مورد آزمون از فضای مورد انتظار کوچکتر نباشد. در واقع وظیفه‌ی بزرگ نشدن یک فضا بر عهده‌ی حداقلهای مورد نظر ما از فضاها دیگر قرار داده شده است.

\paragraph{طول و عرض}
وجود ابعاد استاندارد برای بعضی از فضاها و یا محدودیتهایی که اشیاء درون آنها مثل مبلمان و یا فرش برای ما ایجاد می‌کند می‌تواند ابعاد دقیق فضا را مشخص کند. در این حالت کاربر طول و عرض فضا را برای تابع ارزیابی مشخص می‌کند و تابع ارزیابی سعی می‌کند در حالت عمودی یا افقی فضایی به فضایی با ابعاد مشخص‌شده برسد. جریمه‌ی تبعیت نکردن پاسخ از این شروط به صورت نمایی اعمال می‌شود و به همین دلیل، در بیشتر پاسخها شرط ابعاد رعایت می‌شود. در تعریف مساله‌ی نمونه برای این گزارش ابعاد راه‌پله و آسانسور به این طریق تعیین شده است.

\paragraph{مساحت}
وقتی ابعاد دقیق یک فضا برای ما مشخص نیست، باید مساحت آن را مشخص کنیم. شکل عملی‌تر برای قرار دادن این شرط مشخص کردن سهم هر فضا از کل فضای مربوط به ساختمان است. به بیان دیگر در این روش به دنبال قرار دادن اولویت میان مساحت اتاقها هستیم.

منظور از مساحت در این بخش، مساحت قابل استفاده است. ما انتظار داریم که نسبت میان طول و عرض یک اتاق، در بازه‌ی مشخصی قرار گیرد. برای نمونه اتاقی که طول آن سه برابر عرض آن باشد قابل استفاده نیست و یا حداقل از همه مساحت آن استفاده نمی‌شود. در فرایند تکامل تولید شدن چنین پاسخهایی بسیار محتمل است، پس باید معیار را طوری تعریف کنیم که گرایش این پاسخها به سمت پاسخهای متناسب باشد. برای دستیابی به این هدف بخشی از فضا را که به نظر قابل استفاده می‌رسد، انتخاب می‌کنیم و بخش باقیمانده را نادیده می‌گیریم. به این ترتیب میزان جریمه از تفاضل مساحت مورد انتظار و مساحت قابل استفاده، محاسبه می‌شود.

\begin{figure}[h] \centerline{\includegraphics{AreaRatio}} \caption{\label{fAreaRatio}
بخشی از فضا که در ارزیابی مساحت مورد توجه قرار می‌گیرد
 } \end{figure}

\paragraph{ابعاد فضای دسترسی}
در تعریف این فضا گفته شد که فضای دسترسی شامل یک فضای اصلی (در خانه مسکونی هال) و تعدادی راهرو است. راهرو فضایی است که برای ایجاد دسترسی آن را قرار می‌دهیم و می‌توان گفت مجبور به استفاده از آن هستیم. به این ترتیب به دنبال کاهش تعداد مستطیلهای پوشاننده‌ی فضا هستیم و بهترین حالت، انجام این کار با یک مستطیل است. معیار دیگر برای سنجش کیفیت فضای دسترسی، بزرگ بودن مستطیلها است.

در واقع ما به دنبال پر کردن فضای خالی با کمترین تعداد مستطیل ممکن هستیم و می‌خواهیم این فضا بزرگ و قابل استفاده باشد. البته منظور از بزرگ شدن این فضا، کم کردن مساحت اتاقها نیست بلکه با توجه به جدا بودن معیار ابعاد اتاقها، نتیجه کم شدن فضاهای بی مصرف و افزوده شدن آنها به فضای دسترسی است.

\begin{figure}[h] \centerline{\includegraphics{LessAccessSpaces}} \caption{\label{fLessAccessSpaces}
کاهش تعداد مستطیلها حاصل مرتب چیدن اتاقها
 } \end{figure}

\subsubsection{دسترسی}
همه‌ی فضاهای مورد استفاده در ساختمان باید راهی برای دسترسی داشته باشند. نحوه دسترسی به اتاقهای ساختمان نمونه در این گزارش در شکل زیر نمایش داده شده است. همانطور که در این شکل مشاهده می‌کنید بعضی از اتاقها به طور مستقیم از فضای اصلی مورد دستیابی قرار می‌گیرند و بعضی هم برای دستیابی نیاز به یک (یا چند) واسطه دارند.

\begin{figure}[h] \centerline{\includegraphics{AccessGraph}} \caption{\label{fAccessGraph}
نمودار دسترسی میان اتاقها
 } \end{figure}

محاسبه‌ی میزان جریمه برای دسترسی میان دو فضا با اندازه‌گیری کمترین فاصله‌ای که باید یکی از آنها برای برقراری شرط دسترسی طی کند، انجام می‌شود. برای اینکه دو فضا را از هم قابل دستیابی بدانیم باید میان آن دو، سطح مشترکی حداقل به اندازه طول یک «در» وجود داشته باشد.

در تعریف فضای دسترسی به تشکیل شدن آن از تعدادی مستطیل پوشاننده اشاره کردیم. جریمه‌ی ایجاد دسترسی برای هر فضا از طریق فضای اصلی را با استفاده از روشی که برای دو فضا مطرح کردیم، محاسبه می‌کنیم. در این حالت کمترین فاصله‌ی لازم برای برقراری شرط دسترسی را میان فضا و هر کدام از این مستطیلها محاسبه کرده و کمترین آنها را به عنوان جریمه دسترسی اعلام می‌کنیم.

\begin{figure}[h] \centerline{\includegraphics{AccessCondition}} \caption{\label{fAccessCondition}
شرایط وجود دسترسی میان دو اتاق
 } \end{figure}

\subsubsection{نور}
شاید بتوان گفت یکی از مهمترین ویژگی‌های یک ساختمان نحوه استفاده از نور طبیعی در آن است. اضلاع مختلف ساختمان با توجه به مکان جغرافیایی و جهت قرارگیری آن، بهره‌ها متفاوتی از نور دارند. همچنین عوامل ساخته‌ی بشر می‌توانند مانع از رسیدن نور به بخشهایی از ساختمان شوند. عاملهای طبیعی و مصنوعی موثر روی نور ساختمان جزء محیط محسوب می‌شوند و کاربر نرم‌افزار باید به‌گونه‌ای نور محیط را برای آن مشخص کند. رویه‌ی کنونی به این شکل است که کاربر می‌تواند برای هر ضلع ساختمان، میزان نور را از بین سه گزینه‌ی نور مستقیم، نور آسمان (ضعیف) و بدون نور تعیین کند.

از طرف دیگر هر کدام از اتاقها با توجه به استفاده‌ای که برای آنها در نظر گرفته شده، به میزان مشخصی نیاز به نور دارند. برای نمونه هال و اتاقهای خواب به نور بیشتری نیاز دارند و در مقابل سرویسها و حمام نیازی به نور ندارند. کاربر باید نیاز اتاقها به نور را نیز در قالب همان سه گزینه مشخص کند. تنها فرضی که در نرم‌افزار انجام شده، نیاز فضای اصلی دسترسی (در خانه مسکون هال) به نور مستقیم است.

قرارگیری یکی از اتاقهای نیازمند نور در کنار یکی از اضلاع بهره‌مند از نور، موجب کسب امتیاز در این معیار می‌شود و میزان این امتیاز با مقدار نیاز اتاق، بهره‌مندی ضلع و سطح تماس میان آن دو رابطه مستقیم دارد. به این ترتیب تلاش بر آن است که هر اتاق نیازمند، بیشترین سطح ممکن نورگیری را داشته باشد و اتاقی که نیاز بیشتری دارد، به سمت ضلعی بهره‌مندتر تمایل پیدا می‌کند. همچنین اگر معیارهای دیگر موجود در نقشه، اقتضای محقق نشدن حداکثر نورگیری را داشته باشند، باز هم امکان نورگیری کمتر برای اتاقها با استفاده از مساحت تماس کم و یا ضلع کم نور وجود دارد.

\begin{figure}[h] \centerline{\includegraphics{LightScore}} \caption{\label{fLightScore}
نحوه محاسبه امتیاز برای معیار نور طبیعی
 } \end{figure}

\section{پیاده‌سازی}
نرم‌افزاری که در این پروژه برای رسیدن به هدف تولید نقشه‌ی خانه، ایجاد شده از دو واحد کاملا مجزا تشکیل شده است. واحد مربوط به اجرای فرایند تکامل و واسط گرافیکی نمایش خروجی‌ها که هر کدام در یک پردازه اجرا می‌شوند. مستقل بودن این دو بخش مزایایی دارد که از جمله آنها می‌توان به استفاده بی‌دریغ پردازه‌ی فرایند تکامل از منابع سیستم و امکان اختلال در کار واسط گرافیکی اشاره کرد. همچنین با توجه به امکان اجرای فرایند تکامل به صورت پیاپی و با پارامترهای مختلف، بهتر است بعد از هر اجرا، منابع استفاده شده در پردازه‌ی فرایند تکامل، به سیستم عامل باز گردند و در اجرای بعدی دوباره متناسب با نیازهای نو تخصیص یابند.

\subsection{فرایند تکامل}
در این پروژه برای اجرای فرایند تکامل از چارچوب ParadisEO\LTRfootnote{Parallel and Distributed Evolving Objects} استفاده شده است. جدا بودن بخش تعریف مساله و نحوه‌ی پاسخ‌گویی به آن در این چارچوب امکان اجرای چند نوع فرایند تکامل را فراهم آورده که همه‌ی آنها به شکل واحدی ورودی می‌گیرند و خروجی می‌دهند.

چارچوب متن‌باز ParadisEO به صورت شئ‌گرا و برای اجرای فرایندهای فراابتکاری\LTRfootnote{Metaheuristics} به صورت توزیع‌شده و موازی طراحی شده است. این چارچوب الگوریتم‌های تکاملی و جستجوی موضعی را با استفاده از مدلهای مختلف توزیع و موازی‌سازی فرایندها عرضه کرده و امکان ترکیب این الگوریتم‌ها را نیز فراهم می‌کند.

این چارچوب با استفاده از کتابخانه‌های MPI و PThreads قابلیت اجرا روی ماشین‌هایی با حافظه‌ی توزیع‌شده و یا ماشین‌هایی با حافظه‌ی مشترک و پردازنده‌های توزیع‌شده را دارد و با قرارگیری میان کاربر و این کتابخانه‌ها، پیچیدگی کار با آنها را از کاربر پنهان می‌کند \cite{cahon_paradiseo}. همچنین در نگارشهای آزمایشی این چارچوب، قابلیت استفاده از GPU هم به ویژگی‌ها آن اضافه شده که می‌تواند عملکرد اجرای فرایند را بسیار بهتر کند.
 
\subsection{واسط گرافیکی}
خروجی فرایند تکامل رشته‌ای از اعداد است که آنها را با عنوان ژنوم می‌شناسیم. واسط گرافیکی طراحی شده برای این پروژه وظیفه‌ی نمایش این پاسخها را به صورت یک نقشه‌ی ساختمان بر عهده دارد. پردازه‌ی مربوط به فرایند تکامل طوری تنظیم شده که جمعیت پاسخها را نیز در سیر نسلها ذخیره کند. نرم‌افزار نمایشگر با قابلیت نمایش متوالی این نسلها، رویه‌ی رسیدن به پاسخ را از مراحل آغازین نشان می‌دهد. این نرم‌افزار با زبان C++ در چارچوب Qt نوشته شده است و با توجه به اجازه‌نامه‌ی این چارچوب، قابل انتشار به صورت رایگان است.

\begin{figure}[h] \centerline{\includegraphics{PopulationView}} \caption{\label{fPopulationView}
نمایش جمعیت حاصل فرایند تکامل
 } \end{figure}
 
 از دیگر قابلیتهای این نرم‌افزار محاسبه‌ی مقادیر معیارهای مختلف برای هر کدام از جوابها است. این ویژگی موجب تسهیل فرایند تعریف معیارها و بررسی دقیق تاثیر آنها بر هدایت فرایند تکامل می‌شود. در این راستا نرم‌افزار به کاربر اجازه می‌دهد با تغییر نقشه، نحوه تغییر مقادیر معیارها را مشاهده کند.
 
 \begin{figure}[h] \centerline{\includegraphics{EvaluationView}} \caption{\label{fEvaluationView}
نمایش معیارهای مختلف ارزیابی
 } \end{figure}

\section{نتایج روشهای مختلف}
در بخش فرایندهای تکاملی با تعدادی از روشهای مشهور انجام فرایند تکامل آشنا شدیم. در ادامه نتایج حاصل از اجرای این روشها برای حل این مساله را مشاهده می‌کنیم. در طول استفاده از روشهای مختلف برای انجام این کار هدف رسیدن به مجموعه‌ی جواب خوب و گوناگون بود. برای رسیدن به این هدف روشهای مختلف بررسی شدند و در نهایت روش ترکیبی که در ادامه مورد بحث قرار می‌گیرد، به عنوان پاسخ قابل قبول برگزیده شد. 

\subsection{مثال مورد بررسی}
مساله‌ای که برای نمونه با الگوریتم‌های مختلف حل شده، قرار دادن ۷ اتاق در فضای ساختمان است. قبلا اشاره کردیم که نمایش هر اتاق با چهار عدد حقیقی انجام می‌شود، دو عدد برای فاصله‌ی آن از ضلع بالا و چپ و دو عدد برای طول و عرض. از این رو ژنومی که فرایند تکامل روی آن انجام می‌شود شامل ۲۸ عدد حقیقی است که با توجه به ابعاد ساختمان در بازه ۰ تا ۱۰ تغییر می‌کنند.

ساختمان مساله مستطیل‌شکل و با ابعاد ۱۰/۶ * ۱۰/۰۵ متر است. ضخامت دیوارهای داخلی ۳۰ سانتی‌متر و ضخامت دیوارهای خارجی ۴۵ سانتی‌متر لحاظ شده است. البته باید توجه داشت که برای رعایت این قیود، هر ضلع اتاق با در نظر گرفتن ۱۵ سانتی‌متر حاشیه محاسبه می‌شود، تا قرار گیری دو ضلع در کنار هم، فضای لازم برای قرار دادن دیوار را فراهم کند. ضلع بالای ساختمان نور جنوبی (مستقیم) می‌گیرد و ضلع سمت راست آن نور غربی (غیر مستقیم).

از میان اتاقها ابعاد راه‌پله و آسانسور به طور دقیق مشخص شده و بقیه نسبت مشخصی از مساحت را دریافت می‌کنند. ابعاد راه‌پله ۲/۵ * ۴/۵ متر و ابعاد آسانسور ۱/۶ *‌ ۲ متر است. مساحت آشپزخانه و اتاق خوابها باید ۴ برابر حمام و سرویس بهداشتی باشد و بخش باقیمانده نیز به هال اختصاص می‌یابد.

اتاق هال به نور زیادی نیاز دارد و تمایل آن به حضور در مجاورت ضلع پرنور ساختمان است. همچنین اتاقهای خواب و آشپزخانه نیز نیاز به نور دارند ولی تمایل آنها به نور از هال کمتر است. همانطور که قبلا هم اشاره کردیم، میزان نورگیری اتاقها به صورت امتیاز محاسبه می‌شود و نه جریمه. از این رو وقتی از تمایل بیشتر و کمتر صحبت می‌کنیم، منظور دریافت امتیاز بیشتر برای عضوی از جمعیت است که برای نمونه اتاق هال آن در کنار ظلع نورگیر قرار گرفته است.

\subsection{الگوریتم ژنتیک}
اجرای الگوریتم ژنتیک با عملگرهای تعریف‌شده نتایج چندان جالبی به همراه ندارد. در این حالت اجرای الگوریتم نمی‌تواند تابع ارزیاب پیچیده (شامل همه‌ی موارد گفته شده) را ارضا کند و ادامه‌ی فرایند تکامل منجر به تولید پاسخ نمی‌شود. نتایج اجرا با نسخه‌ی ساده شده‌ی تابع ارزیاب (شامل مساحت و تداخل) منجر به تولید خروجی‌های نسبتا قابل قبولی می‌شود که البته چندان متنوع نیستند.

در ادامه نتایج حاصل از اجرای الگوریتم ژنتیک با جمعیت ۴۹ عضو‌ (برای نمایش بهتر) را مشاهده می‌کنیم. این نتایج با عبور از ۲۰۰۰ نسل تولید شده‌اند ولی همانطور که گفته شد، حتی شروط مساحت و تداخل را نیز سه سختی ارضا می‌کنند. جمعیت اولیه از ۲۸ عدد اتفاقی در بازه‌ی ۰ تا ۶ آغاز شده و هر بار به اندازه‌ی جمعیت، فرزند جدید از میان آنها تولید می‌شود.

عملگر جهش عدد حقیقی همیشه در آن اتفاق می‌افتد و مقدار این جهش از یک توزیع یکنواخت پیرامون صفر و با اندازه‌ی ۰/۰۵ انجام می‌شود. همچنین عملگر جهش تغییر مکان دو اتاق با احتمال 0/02 اتفاق می‌افتد. عملگر ترکیب با احتمال 0/1 انجام می‌شود و در صورت وقوع این عملگر مکان هر دو اتاق به احتمال 0/1 با هم عوض می‌شود.

والدها به طور ترتیبی از میان اعضا انتخاب می‌شوند و در هنگام انتخاب نسل جدید، فرزندان به طور کامل جایگزین نسل قبل خواهند شد. البته مکانیزیم weak elitism نیز مورد استفاده قرار گرفته که در آن بهترین والد از نسل قبل، در صورت برتری، جایگزین بدترین فرزند نسل جدید می‌شود.

\begin{figure}[h] \centerline{\includegraphics{GeneticAlgorithmResults}} \caption{\label{fGeneticAlgorithmResults}
نتایج حاصل از اجرای الگوریتم ژنتیک
} \end{figure}

\subsection{استراتژی تکاملی}
اجرای این روش بدون استفاده از عملگرهای تعریف شده مخصوص مساله موجب تولید جواب بسیار قابل قبولی شد. این نتیجه ممکن است کمی عجیب به نظر برسد و ضرورت تعریف عملگرهای مناسب مساله را زیر سوال ببرد. نتایج و بررسی‌های بعدی نشان داد که اجرای این روش برای رسیدن به پاسخ، عملا منجر به اجرای یک جستجوی موضعی می‌شود و مستقل از تعداد جمعیت آغاز کننده فرایند تکامل، این فرایند به یک پاسخ بهینه‌ی موضعی همگرا می‌شود. این نکته‌ی بسیار مهم باعث شد که گزینه‌ی استفاده از عملگر جستجوی موضعی را مورد بررسی قرار دهیم.

جمعیت نهایی که در شکل زیر مشاهده می‌کنیم، حاصل اجرای الگورتیم استراتژی تکاملی با ۴۹ عضو و در طی ۳۰۰ نسل تکامل است. ادامه‌ی این فرایند تاثیر چندانی بر کیفیت پاسخها ندارد که نشان از سرعت همگرا شدن این الگوریتم به پاسخ است. همانطور که اشاره شد، در این الگوریتم تعداد فرزندان زیادی باید تولید شوند تا پاسخ مناسبی بدست آید و در این آزمایش نیز نسبت آنها ۷ برابر جمعیت اولیه تنظیم شده است. برای انتخاب والد و جایگزینی نسل جدید نیز پارامترها دقیقا مشابه الگوریتم ژنتیک تنظیم شده‌اند.

 برای آسان شدن فرایند حل، تنها یک طول گام با مقدار اولیه ۰/۸ درصد، برای همه‌ی ژنها در ژنوم قرار داده شده که طول آن را به ۲۹ عدد می‌رساند. البته قرار دادن یک طول گام برای هر ژن نیز مورد بررسی قرار گرفت ولی نتایج الگوریتم تفاوت چندانی نداشت. 

\begin{figure}[h] \centerline{\includegraphics{EvolutionStrategyResults}} \caption{\label{fEvolutionStrategyResults}
نتایج حاصل از اجرای الگوریتم استراتژی تکاملی
} \end{figure}

\subsection{روشهای چند هدفه}
مساله‌ای که در پی آن هستیم، در باطن یک مساله چند هدفه است. تابع ارزیابی معمول که در همه روشها استفاده شده، حاصل جمع ارزیابی مربوط به اهداف مختلف است ولی در این روش، ارزیابی هر کدام از اهداف به طور مستقل برای مقایسه‌ها استفاده می‌شود. به این ترتیب انتظار می‌رود که نتایج خوبی بدست آید که همه‌ی اهداف در آنها تا حدی برآورده شده باشند.

اما همانطور که در شکل مشاهده می‌کنیم، نتایج عملی اصلا این موضوع را نشان نمی‌دهد. وقتی همه‌ی اهداف مورد توجه قرار می‌گیرند، خروجی بسیار بد است. حتی وقتی تنها عوامل مساحت و تداخل اعمال می‌شوند باز هم نتایج چندان قابل توجه نیست.

نکته‌ی بسیار مهم در این روش و الگوریتم ژنتیک آن است که با افزایش تعداد فرزندان تولید شده و همچنین بالا بردن نقش عملگر جهش می‌توان به خروجی‌های بهتر و البته تقریبا همگرا دست یافت. البته پیداست که این عوامل فرایند تکامل را به جستجوی محلی تبدیل می‌کنند.

\begin{figure}[h] \centerline{\includegraphics{MultiObjectiveResults}} \caption{\label{fMultiObjectiveResults}
نتایج بی‌ارزش، حاصل اجرای روش چند هدفه
} \end{figure}

\subsection{روشهای ترکیبی}
مشاهده‌ی نتایج روشهای قبل به وضوح نشان از عملکر قوی الگوریتم‌های جستجوی موضعی برای حل این مساله دارد. اشاره کردیم که هدف اصلی رسیدن به مجموعه‌ای گوناگون و خوب است. به همین دلیل گزینه‌ی روشهای ترکیبی مورد بررسی قرار گرفت. با توجه به محدودیت زمانی، تنها الگوریتم بالا رفتن از تپه آزمایش شد که تا حدی هدف اولیه را محقق کرد. در واقع با مشاهده نتایج این الگوریتم می‌توان ادعا کرد که فرایند تکامل وظیفه‌ی محول شده به آن را انجام می‌دهد و اگر نقشه‌ی بدست آمده مناسب سکونت نیست، نقص اصلی مربوط به تعریف مساله و تابع ارزیابی آن است.

نتایجی که در ادامه از این الگوریتم مشاهده می‌کنیم، برگزیده از یک بار اجرای آن با جمعیت ۴۹ عضو و در طول ۲۰۰ نسل تکامل هستند. تعداد فرزندان برابر تعداد والدها قرار داده شده و انتخاب والد و جایگزینی نسل نیز در این اجرا مشابه الگوریتم ژنتیک تنظیم شده است.

عملگر بالا رفتن از تپه به عنوان نوعی عملگر جهش پیاده‌سازی شده است. به طور خلاصه می‌توان گفت بالا رفتن از تپه به شکل تولید تعداد همسایه برای عضو ژنوم و سپس انتخاب بهترین آنها به صورت متوالی است. در واقع این عملگر روی هر ژنومی که اعمال می‌شود آن را حداکثر تا ۵۰ مرحله (انتخاب بهترین همسایه) قرار می‌گیرد. البته روشن است که در بسیاری از موارد ممکن است با چند بار ارتقا به یک نقطه‌ی بهینه‌ی موضعی برسیم و این فرایند متوقف شود.

به غیر از عملگر جهش جستجوی موضعی، عملگر جهش تغییر مکان اتاقها هم با احتمال 0/2 اعمال می‌شود. همچین ترکیب به صورت ادغام اتاقها نیز با احتمال ۰/۲ در هنگام تولید فرزند، مورد استفاده قرار می‌گیرد.

\begin{figure}[h] \centerline{\includegraphics{HybridResults}} \caption{\label{fHybridResults}
نتایج برگزیده از اجرای روش ترکیبی
} \end{figure}

\section{نتایج برگزیده}

\section{نتیجه‌گیری}
برای ترسیم نقشه‌ی ساختمان که البته به چیدن اتاقها در خانه تنزل یافت، راه‌های متنوعی را آزامایش کردیم. پاسخهای بدست آمده شاید خانه‌های خوبی نباشند و یا حتی زندگی در آنها سخت باشد، در هر حال به نظر می‌رسد خانه‌هایی تولید شده‌اند. روشهایی که برای انجام این پروژه مورد استفاده قرار گرفت، نمایانگر سیری است که هر گام آن مطابق نیاز برداشته شده است. ابتدا استفاده از یک الگوریتم ژنتیک ساده، بعد الگوریتمی که احتمال بیشتری برای رسیدن به پاسخ دارد و البته تنها یک پاسخ تولید می‌کند. سپس استفاده از روش چند هدفه برای دستیابی به گوناگونی در پاسخها و مشاهده‌ی ارتقای جواب با نزدیک شدن به جستجوی موضعی و در نهایت رسیدن به پاسخها قابل قبول با ترکیب جستجوی موضعی و فرایند تکامل.
   
\section{کارهای آینده}
برنامه‌های زیادی برای توسعه‌ی این پروژه وجود دارد که امید تحقق آنها را داریم. پس از یک‌بار طی کردن مراحل استفاده از فرایند تکامل برای حل مساله با نگاهی بازتر می‌توانیم، مشکلات هر مرحل را بررسی کنیم. نحوه‌ی ارائه‌ی مساله به شکل مستطیل‌های مستقل از هم، تقریبا ساده‌ترین شکل ممکن برای ارائه‌ی چنین مساله‌ای است. در این ارائه اتاقها می‌توانند روی هم قرار بگیرند و یا ممکن است اتاقها همه‌ی فضای ساختمان را پر نکنند. این مشکلات نشان می‌دهد که نحوه ارائه با صورت مساله قرابت خاصی ندارد.

ارائه‌های مختلفی را می‌توان برای حل این مساله در نظر گرفت. برای نمونه می‌توان به جای اتاقها، دیوارها را در مساله قرار داد که البته این ارائه هم ابهامات مربوط به خود را دارد. یک نوع ارائه پیشنهادی برای ادامه‌ی مسیر پروژه، بیان اتاقها تنها با یک نقطه است. در این نوع ارائه هر دیوار دقیقا وسط دو نقطه قرار گرفته است. برای تقسیم ساختمان به چند مستطیل با استفاده از نقطه‌ها، کافیست ابتدا دیوار بین دو نقطه‌ی اول را رسم کنیم تا نقشه به دو بخش تقسیم شود و سپس همین کار را برای هر بخش انجام دهیم تا هر نقطه در یک بخش قرار گیرد.

در روش ارائه‌ی پیشنهادی هیچ دو اتاقی روی هم قرار نمی‌گیرند و همیشه فضای ساختمان با اتاقها پر می‌شود. در این ساختار معمولا تغییرات کوچک در جای نقطه‌ها موجب وقوع تغییرات کوچک در میزان ارزشمندی پاسخ می‌شود. از این شواهد می‌توان نتیجه گرفت که این مساله با فرایند تکامل قابل حل است.

در حوزه‌ی ساختمانها نیز، تلاش بر عبور از خانه و رسیدن به انواع ساختمانها است. همچنین بررسی زمینهای چهار ضلعی و نه لزوما مستطیل که در ساختار شهر به وفور پیدا می‌شوند. چالشهای مربوط به ساختمانهای چند طبقه و همچنین فضاهای آزاد مثل دانشگاه نیز پیش روی این پروژه هستند. البته همه‌ی این موارد باید در کنار ارتقای کیفی معیارها و همچنین استفاده از معیارهای جدید انجام بگیرند.

\renewcommand*{\refname}{\section{منابع}}
\begin{thebibliography}{9}
\begin{latin}

\bibitem{eiben_evolutionary_computing}
A. E. Eiben and J. E. Smith, Introduction to evolutionary computing. Springer Verlag, 2003.

\bibitem{cahon_paradiseo}
S. Cahon, N. Melab, and E.-G. Talbi, “ParadisEO: A Framework for the Reusable Design of Parallel and Distributed Metaheuristics,” Journal of Heuristics, vol. 10, pp. 357-380, May 2004.

\end{latin}
\end{thebibliography}

\end{document}
